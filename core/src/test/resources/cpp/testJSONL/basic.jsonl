{"code":"#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    if (true && true) {\n        cout << \"Hello World!\";\n    }\n    return 0;\n}\n\n","text":"and_keyword.cpp"}
{"code":"#include<cstring>\n#include<cstdio>\n\nusing namespace std;\n\nclass CMyString\n{\npublic:\n\tCMyString(const char* pData = nullptr);\n\tCMyString(const CMyString& str);\n\t~CMyString(void);\n\n\tCMyString& operator = (const CMyString& str);\n\n\tvoid Print();\n\nprivate:\n\tchar* m_pData;\n};\n\nCMyString::CMyString(const  char *pData)\n{\n\tif (pData == nullptr)\n\t{\n\t\tm_pData = new char[1];\n\t\tm_pData[0] = '\\0';\n\t}\n\telse\n\t{\n\t\tint length = strlen(pData);\n\t\tm_pData = new char[length + 1];\n\t\tstrcpy_s(m_pData,length+1, pData);\n\t}\n}\n\nCMyString::CMyString(const CMyString &str)\n{\n\tint length = strlen(str.m_pData);\n\tm_pData = new char[length + 1];\n\tstrcpy_s(m_pData,length+1, str.m_pData);\n}\n\nCMyString::~CMyString()\n{\n\tdelete[] m_pData;\n}\n\nCMyString& CMyString::operator = (const CMyString& str)\n{\n\tif (&str != this)\n\t{\n\t\tCMyString strTemp(str);\n\t\tchar* pTemp = strTemp.m_pData;\n\t\tstrTemp.m_pData = m_pData;\n\t\tm_pData = pTemp;\n\t}\n\n\treturn *this;\n}","text":"class_test.cpp"}
{"code":"#include <iostream>\r\n#include <exception>\r\nusing namespace std;\r\n\r\nstruct MyException : public exception\r\n{\r\n  const char * what () const throw ()\r\n  {\r\n    return \"C++ Exception\";\r\n  }\r\n};\r\n\r\nstruct test\r\n{\r\n    int i;\r\n    test(int iii)\r\n    :i(iii){}\r\n\r\n    test(int ii)\r\n    try:i(ii)\r\n    {\r\n        i=1;\r\n    }\r\n    catch(std::exception& e)\r\n    {\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n  try\r\n  {\r\n    int i=1;\r\n    if(i==1)\r\n        throw MyException();\r\n    i=2;\r\n    switch(i)\r\n    {\r\n        case 1:i=1;\r\n            break;\r\n        case 2:i=2;\r\n            break;\r\n        default:i=0;\r\n    }\r\n  }\r\n  catch(MyException& e)\r\n  {\r\n    std::cout << \"MyException caught\" << std::endl;\r\n    std::cout << e.what() << std::endl;\r\n  }\r\n  catch(std::exception& e)\r\n  {\r\n    //其他的错误\r\n  }\r\n  return 0;\r\n}","text":"exception_test.cpp"}
{"code":"#include <iostream>\r\nusing namespace std;\r\n\r\n\r\nvoid main() {\r\n\tfor (int i = 1; i < 100; i++) {\r\n//\tint x =0;\r\n//\tx=x+1;\r\n\t\tif (i % 2 == 0) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tstd::cout << i << endl;\r\n\t\t}\r\n\t}\r\n\r\n    //goto语句\r\n\r\n    \tgoto here ;\r\n    \tcout << \"本应该输出这句。\" << endl;\r\n    here:\r\n    \tcout << \"现在打印这句。\" <<  endl;\r\n    \treturn 0;\r\n\r\n\r\n\r\n}","text":"for_if_test.cpp"}
{"code":"#include <ctpl.h>\n#include <iostream>\n#include <string>\n\n\n\nvoid first(int id) {\n    std::cout << \"hello from \" << id << \", function\\n\";\n}\n\nvoid aga(int id, int par) {\n    std::cout << \"hello from \" << id << \", function with parameter \" << par <<'\\n';\n}\n\nstruct Third {\n    Third(int v) { this->v = v; std::cout << \"Third ctor \" << this->v << '\\n'; }\n    Third(Third && c) { this->v = c.v; std::cout<<\"Third move ctor\\n\"; }\n    Third(const Third & c) { this->v = c.v; std::cout<<\"Third copy ctor\\n\"; }\n    ~Third() { std::cout << \"Third dtor\\n\"; }\n    int v;\n};\n\nvoid mmm(int id, const std::string & s) {\n    std::cout << \"mmm function \" << id << ' ' << s << '\\n';\n}\n\nvoid ugu(int id, Third & t) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n    std::cout << \"hello from \" << id << \", function with parameter Third \" << t.v <<'\\n';\n}\n\nint main(int argc, char **argv) {\n    ctpl::thread_pool p(2 /* two threads in the pool */);\n\n    std::future<void> qw = p.push(std::ref(first));  // function\n    p.push(first);  // function\n    p.push(aga, 7);  // function\n\n    {\n        struct Second {\n            Second(const std::string & s) { std::cout << \"Second ctor\\n\"; this->s = s; }\n            Second(Second && c) { std::cout << \"Second move ctor\\n\"; s = std::move(c.s); }\n            Second(const Second & c) { std::cout << \"Second copy ctor\\n\"; this->s = c.s; };\n            ~Second() { std::cout << \"Second dtor\\n\"; }\n            void operator()(int id) const {\n                std::cout << \"hello from \" << id << ' ' << this->s << '\\n';\n            }\n        private:\n            std::string s;\n        } second(\", functor\");\n\n        p.push(std::ref(second));  // functor, reference\n        std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n        p.push(const_cast<const Second &>(second));  // functor, copy ctor\n        p.push(std::move(second));  // functor, move ctor\n        p.push(second);  // functor, move ctor\n        p.push(Second(\", functor\"));  // functor, move ctor\n    }\n        {\n            Third t(100);\n\n            p.push(ugu, std::ref(t));  // function. reference\n            p.push(ugu, t);  // function. copy ctor, move ctor\n            p.push(ugu, std::move(t));  // function. move ctor, move ctor\n\n        }\n        p.push(ugu, Third(200));  // function\n\n\n\n    std::string s = \", lambda\";\n    p.push([s](int id){  // lambda\n        std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n        std::cout << \"hello from \" << id << ' ' << s << '\\n';\n    });\n\n    p.push([s](int id){  // lambda\n        std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n        std::cout << \"hello from \" << id << ' ' << s << '\\n';\n    });\n\n    p.push(mmm, \"worked\");\n\n    auto f = p.pop();\n    if (f) {\n        std::cout << \"poped function from the pool \";\n        f(0);\n    }\n    // change the number of treads in the pool\n\n    p.resize(1);\n\n    std::string s2 = \"result\";\n    auto f1 = p.push([s2](int){\n        return s2;\n    });\n    // other code here\n    //...\n    std::cout << \"returned \" << f1.get() << '\\n';\n\n    auto f2 = p.push([](int){\n        throw std::exception();\n    });\n    // other code here\n    //...\n    try {\n        f2.get();\n    }\n    catch (std::exception & e) {\n        std::cout << \"caught exception\\n\";\n    }\n\n    // get thread 0\n    auto & th = p.get_thread(0);\n\n    return 0;\n}\n\n","text":"function_and_struct_definations_test.cpp"}
{"code":"int foo();\nfloat foo( short s );\nint foo( short int si=1 );\n","text":"function_Declarations_and_integers.cpp"}
{"code":"#include <iostream>\r\nusing namespace std;\r\nint main(int argc, const char * argv[]) {\r\n\r\n    cout<<\"1111111\"<<endl;\r\n    cout<<\"2222222\"<<endl;\r\n    //GOTO 跳转到前置label\r\n    LABEL2:\r\n        cout<<\"5555555\"<<endl;\r\n        //goto跳转到后置label\r\n    goto EXIT;\r\n    cout<<\"3333333\"<<endl;\r\n    EXIT:\r\n    cout<<\"4444444\"<<endl;\r\n    goto LABEL2;\r\n\r\n    return 0;\r\n}","text":"goto_test.cpp"}
{"code":"#include <iostream>\r\nusing namespace std;\r\n\r\nint main ()\r\n{\r\n   // 局部变量声明\r\n   int a = 10;\r\n\r\n   // while 循环执行\r\n   while( a < 20 )\r\n   {\r\n       cout << \"a 的值：\" << a << endl;\r\n       a++;\r\n   }\r\n\r\n   for( int a = 10; a < 20; a = a + 1 )\r\n  {\r\n      cout << \"a 的值：\" << a << endl;\r\n  }\r\n\r\n  do\r\n  {\r\n      cout << \"a 的值：\" << a << endl;\r\n      a = a + 1;\r\n  }while( a < 20 );\r\n\r\n   return 0;\r\n}","text":"iteration_test.cpp"}
{"code":"#include<iostream>\r\nusing namespace std;\r\n//使用switch语句打印一位数中文数字\r\n\r\nint main()\r\n{\r\n\tint num = 6 ;\r\n\tswitch (num)\r\n\t{\r\n\t\tcase 0:\r\n\t\t\tcout << \"零\" << endl;\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tcout << \"一\" << endl;\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tcout << \"二\" << endl;\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\tcase 4:\r\n\t\tcase 5:\r\n\t\tcase 6:\r\n\t\tcase 7:\r\n\t\t\tcout << \"七\" << endl;\r\n\t\t\tbreak;\r\n\t\tcase 8:\r\n\t\tcase 9:\r\n\t\tdefault :\r\n\t\t\tcout << \"数字不在0-9之间！\" << endl;\r\n\t\t\tbreak;\r\n\t}\r\n\treturn 0 ;\r\n}\r\n\r\n","text":"switch_test.cpp"}
{"code":"/*********************************************************\n*\n*  Copyright (C) 2014 by Vitaliy Vitsentiy\n*\n*  Licensed under the Apache License, Version 2.0 (the \"License\");\n*  you may not use this file except in compliance with the License.\n*  You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n*  Unless required by applicable law or agreed to in writing, software\n*  distributed under the License is distributed on an \"AS IS\" BASIS,\n*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n*  See the License for the specific language governing permissions and\n*  limitations under the License.\n*\n*********************************************************/\n\n\n#ifndef __ctpl_stl_thread_pool_H__\n#define __ctpl_stl_thread_pool_H__\n\n#include <functional>\n#include <thread>\n#include <atomic>\n#include <vector>\n#include <memory>\n#include <exception>\n#include <future>\n#include <mutex>\n#include <queue>\n\ntemplate <class Type>\nType min( Type a, Type b ) {\n    return a < b ? a : b;\n}\n\n// thread pool to run user's functors with signature\n//      ret func(int id, other_params)\n// where id is the index of the thread that runs the functor\n// ret is some return type\n\n\nnamespace ctpl {\n\n    namespace detail {\n        template <typename T>\n        class Queue {\n        public:\n            bool push(T const & value) {\n                std::unique_lock<std::mutex> lock(this->mutex);\n                this->q.push(value);\n                return true;\n            }\n            // deletes the retrieved element, do not use for non integral types\n            bool pop(T & v) {\n                std::unique_lock<std::mutex> lock(this->mutex);\n                if (this->q.empty())\n                    return false;\n                v = this->q.front();\n                this->q.pop();\n                return true;\n            }\n            bool empty() {\n                std::unique_lock<std::mutex> lock(this->mutex);\n                return this->q.empty();\n            }\n        private:\n            std::queue<T> q;\n            std::mutex mutex;\n        };\n    }\n\n    class thread_pool {\n\n    public:\n\n        thread_pool() { this->init(); }\n        thread_pool(int nThreads) { this->init(); this->resize(nThreads); }\n\n        // the destructor waits for all the functions in the queue to be finished\n        ~thread_pool() {\n            this->stop(true);\n        }\n\n        // get the number of running threads in the pool\n        int size() { return static_cast<int>(this->threads.size()); }\n\n        // number of idle threads\n        int n_idle() { return this->nWaiting; }\n        std::thread & get_thread(int i) { return *this->threads[i]; }\n\n        // change the number of threads in the pool\n        // should be called from one thread, otherwise be careful to not interleave, also with this->stop()\n        // nThreads must be >= 0\n        void resize(int nThreads) {\n            if (!this->isStop && !this->isDone) {\n                int oldNThreads = static_cast<int>(this->threads.size());\n                if (oldNThreads <= nThreads) {  // if the number of threads is increased\n                    this->threads.resize(nThreads);\n                    this->flags.resize(nThreads);\n\n                    for (int i = oldNThreads; i < nThreads; ++i) {\n                        this->flags[i] = std::make_shared<std::atomic<bool>>(false);\n                        this->set_thread(i);\n                    }\n                }\n                else {  // the number of threads is decreased\n                    for (int i = oldNThreads - 1; i >= nThreads; --i) {\n                        *this->flags[i] = true;  // this thread will finish\n                        this->threads[i]->detach();\n                    }\n                    {\n                        // stop the detached threads that were waiting\n                        std::unique_lock<std::mutex> lock(this->mutex);\n                        this->cv.notify_all();\n                    }\n                    this->threads.resize(nThreads);  // safe to delete because the threads are detached\n                    this->flags.resize(nThreads);  // safe to delete because the threads have copies of shared_ptr of the flags, not originals\n                }\n            }\n        }\n\n        // empty the queue\n        void clear_queue() {\n            std::function<void(int id)> * _f;\n            while (this->q.pop(_f))\n                delete _f; // empty the queue\n        }\n\n        // pops a functional wrapper to the original function\n        std::function<void(int)> pop() {\n            std::function<void(int id)> * _f = nullptr;\n            this->q.pop(_f);\n            std::unique_ptr<std::function<void(int id)>> func(_f); // at return, delete the function even if an exception occurred\n            std::function<void(int)> f;\n            if (_f)\n                f = *_f;\n            return f;\n        }\n\n        // wait for all computing threads to finish and stop all threads\n        // may be called asynchronously to not pause the calling thread while waiting\n        // if isWait == true, all the functions in the queue are run, otherwise the queue is cleared without running the functions\n        void stop(bool isWait = false) {\n            if (!isWait) {\n                if (this->isStop)\n                    return;\n                this->isStop = true;\n                for (int i = 0, n = this->size(); i < n; ++i) {\n                    *this->flags[i] = true;  // command the threads to stop\n                }\n                this->clear_queue();  // empty the queue\n            }\n            else {\n                if (this->isDone || this->isStop)\n                    return;\n                this->isDone = true;  // give the waiting threads a command to finish\n            }\n            {\n                std::unique_lock<std::mutex> lock(this->mutex);\n                this->cv.notify_all();  // stop all waiting threads\n            }\n            for (int i = 0; i < static_cast<int>(this->threads.size()); ++i) {  // wait for the computing threads to finish\n                    if (this->threads[i]->joinable())\n                        this->threads[i]->join();\n            }\n            // if there were no threads in the pool but some functors in the queue, the functors are not deleted by the threads\n            // therefore delete them here\n            this->clear_queue();\n            this->threads.clear();\n            this->flags.clear();\n        }\n\n        template<typename F, typename... Rest>\n        std::future<decltype(f(0, rest...))> push(F && f, Rest&&... rest)  {\n            auto pck = std::make_shared<std::packaged_task<decltype(f(0, rest...))(int)>>(\n                std::bind(std::forward<F>(f), std::placeholders::_1, std::forward<Rest>(rest)...)\n                );\n            auto _f = new std::function<void(int id)>([pck](int id) {\n                (*pck)(id);\n            });\n            this->q.push(_f);\n            std::unique_lock<std::mutex> lock(this->mutex);\n            this->cv.notify_one();\n            return pck->get_future();\n        }\n\n        // run the user's function that excepts argument int - id of the running thread. returned value is templatized\n        // operator returns std::future, where the user can get the result and rethrow the catched exceptins\n        template<typename F>\n        std::future<decltype(f(0))> push(F && f)  {\n            auto pck = std::make_shared<std::packaged_task<decltype(f(0))(int)>>(std::forward<F>(f));\n            auto _f = new std::function<void(int id)>([pck](int id) {\n                (*pck)(id);\n            });\n            this->q.push(_f);\n            std::unique_lock<std::mutex> lock(this->mutex);\n            this->cv.notify_one();\n            return pck->get_future();\n        }\n\n\n    private:\n\n        // deleted\n        thread_pool(const thread_pool &);// = delete;\n        thread_pool(thread_pool &&);// = delete;\n        thread_pool & operator=(const thread_pool &);// = delete;\n        thread_pool & operator=(thread_pool &&);// = delete;\n\n        void set_thread(int i) {\n            std::shared_ptr<std::atomic<bool>> flag(this->flags[i]); // a copy of the shared ptr to the flag\n            auto f = [this, i, flag/* a copy of the shared ptr to the flag */]() {\n                std::atomic<bool> & _flag = *flag;\n                std::function<void(int id)> * _f;\n                bool isPop = this->q.pop(_f);\n                while (true) {\n                    while (isPop) {  // if there is anything in the queue\n                        std::unique_ptr<std::function<void(int id)>> func(_f); // at return, delete the function even if an exception occurred\n                        (*_f)(i);\n                        if (_flag)\n                            return;  // the thread is wanted to stop, return even if the queue is not empty yet\n                        else\n                            isPop = this->q.pop(_f);\n                    }\n                    // the queue is empty here, wait for the next command\n                    std::unique_lock<std::mutex> lock(this->mutex);\n                    ++this->nWaiting;\n                    this->cv.wait(lock, [this, &_f, &isPop, &_flag](){ isPop = this->q.pop(_f); return isPop || this->isDone || _flag; });\n                    --this->nWaiting;\n                    if (!isPop)\n                        return;  // if the queue is empty and this->isDone == true or *flag then return\n                }\n            };\n            this->threads[i].reset(new std::thread(f)); // compiler may not support std::make_unique()\n        }\n\n        void init() { this->nWaiting = 0; this->isStop = false; this->isDone = false; }\n\n        std::vector<std::unique_ptr<std::thread>> threads;\n        std::vector<std::shared_ptr<std::atomic<bool>>> flags;\n        detail::Queue<std::function<void(int id)> *> q;\n        std::atomic<bool> isDone;\n        std::atomic<bool> isStop;\n        std::atomic<int> nWaiting;  // how many threads are waiting\n\n        std::mutex mutex;\n        std::condition_variable cv;\n    };\n\n}\n\n#endif // __ctpl_stl_thread_pool_H__\n","text":"template_args_test.cpp"}
{"code":"#include <iostream> \n#include <regex> \n#include<string.h>\n#include<stack>\n#include<conio.h>\nusing namespace std;\n\nint main()\n{\n\tint i = 0;\n\tint y = 1;\n\tint&const icr = i; //const reference\n\tint& const icr1 = i; // const reference \n\tint &const icr2 = i; //const reference\n\tint & const icr3 = i; //const reference\n\ticr = y;          \n\ticr = 99;         \n\tint x = 9;\n\ticr = x;\n\tcout << \"icr: \" << icr << \", y:\" << y << endl;\n\n\n\t_getch();\n\treturn 0;\n}\n","text":"test1.cpp"}

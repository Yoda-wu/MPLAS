{"code":"int main()\r\n{\r\n    /**\r\n      * testing the 3 functions\r\n      */\r\n    std::vector<int>* ptr_vi = dynamic_vector_generator();\r\n    dynamic_vector_processor(ptr_vi);\r\n    dynamic_vector_printer(ptr_vi);\r\n\r\n    delete ptr_vi;\r\n\r\n    return 0;\r\n}","text":"a.cpp"}
{"code":"#include \"ex12_02.h\"\n#include <iostream>\n\nint main()\n{\n    const StrBlob csb{\"hello\", \"world\", \"pezy\"};\n    StrBlob sb{\"hello\", \"world\", \"Mooophy\"};\n\n    std::cout << csb.front() << \" \" << csb.back() << std::endl;\n    sb.back() = \"pezy\";\n    std::cout << sb.front() << \" \" << sb.back() << std::endl;\n}\n","text":"ex12_02_TEST.cpp"}
{"code":"/***************************************************************************\n *  @file       The code is for the exercises in C++ Primmer 5th Edition\n *  @author     Alan.W\n *  @date       22  DEC 2013\n *  @remark\n ***************************************************************************/\n//!\n//! Exercise 12.6:\n//! Write a function that returns a dynamically allocated vector of ints.\n//! Pass that vector to another function that reads the standard input to\n//! give values to the elements. Pass the vector to another function to print\n//! the values that were read.\n//! Remember to delete the vector at the appropriate time.\n//!\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <memory>\n\nstd::vector<int>* dynamic_vector_generator();\n\nvoid dynamic_vector_processor(std::vector<int>* ptr_v);\n\nvoid dynamic_vector_printer(std::vector<int>* ptr_v);\n\nint main()\n{\n    /**\n      * testing the 3 functions\n      */\n    std::vector<int>* ptr_vi = dynamic_vector_generator();\n    dynamic_vector_processor(ptr_vi);\n    dynamic_vector_printer(ptr_vi);\n\n    delete ptr_vi;\n\n    return 0;\n}\n\n/**\n *  @brief  return a pointer to dynamicly allocated vector of ints\n */\nstd::vector<int>* dynamic_vector_generator()\n{\n    std::vector<int>* ptr_v = new std::vector<int>();\n    return ptr_v;\n}\n\n/**\n * @brief return a pointer to vector of ints\n * @param ptr_v pointer to vector of ints\n */\nvoid dynamic_vector_processor(std::vector<int>* ptr_v)\n{\n    int i;\n    std::cout << \"plz enter:\\n\";\n    while (std::cin >> i && i != 999) ptr_v->push_back(i);\n}\n\n/**\n * @brief print the content of the vector that ptr_v points to\n * @param ptr_v\n */\nvoid dynamic_vector_printer(std::vector<int>* ptr_v)\n{\n    for (const auto& e : *ptr_v) std::cout << e << \" \";\n    std::cout << \"\\n\";\n}\n","text":"ex12_06.cpp"}
{"code":"/***************************************************************************\n *  @file       The code is for the exercises in C++ Primmer 5th Edition\n *  @author     Alan.W\n *  @date       22  DEC 2013\n *  @remark\n ***************************************************************************/\n//!\n//! Exercise 12.6:\n//! Write a function that returns a dynamically allocated vector of ints.\n//! Pass that vector to another function that reads the standard input to\n//! give values to the elements. Pass the vector to another function to print\n//! the values that were read.\n//! Remember to delete the vector at the appropriate time.\n//!\n//! Exercise 12.7:\n//! Redo the previous exercise, this time using shared_ptr.\n//!\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <memory>\n\n/**\n * @brief   functions for ex12.6\n */\nstd::vector<int>* dynamic_vector_generator();\n\nvoid dynamic_vector_processor(std::vector<int>* ptr_v);\n\nvoid dynamic_vector_printer(std::vector<int>* ptr_v);\n\n/**\n * @brief   functions for ex12.7\n */\nstd::shared_ptr<std::vector<int>> dynamic_vector_generator_sptr();\n\nvoid dynamic_vector_processor_sptr(std::shared_ptr<std::vector<int>> sptr_vi);\n\nvoid dynamic_vector_printer_sptr(\n    const std::shared_ptr<std::vector<int>> sptr_vi);\n\nint main()\n{\n    auto sptr = dynamic_vector_generator_sptr();\n    dynamic_vector_processor_sptr(sptr);\n    dynamic_vector_printer_sptr(sptr);\n\n    return 0;\n}\n\n/**\n *  @brief  return a pointer to dynamicly allocated vector of ints\n *          ex12.6\n */\nstd::vector<int>* dynamic_vector_generator()\n{\n    std::vector<int>* ptr_v = new std::vector<int>();\n    return ptr_v;\n}\n\n/**\n * @brief   return a pointer to vector of ints\n *          ex12.6\n * @param   ptr_v pointer to vector of ints\n */\nvoid dynamic_vector_processor(std::vector<int>* ptr_v)\n{\n    int i;\n    std::cout << \"plz enter:\\n\";\n    while (std::cin >> i && i != 999) ptr_v->push_back(i);\n}\n\n/**\n * @brief   print the content of the vector that ptr_v points to\n *          ex12.6\n * @param   ptr_v\n */\nvoid dynamic_vector_printer(std::vector<int>* ptr_v)\n{\n    for (const auto& e : *ptr_v) std::cout << e << \" \";\n    std::cout << \"\\n\";\n}\n\n/**\n * @brief   return a shared_prt to vector of ints\n */\nstd::shared_ptr<std::vector<int>> dynamic_vector_generator_sptr()\n{\n    return std::make_shared<std::vector<int>>();\n}\n\n/**\n* @brief    using std IO adding elelements into the vetor and\n*           return a shared_ptr pointing to it\n* @param    sptr_vi\n*/\nvoid dynamic_vector_processor_sptr(std::shared_ptr<std::vector<int>> sptr_vi)\n{\n    int i;\n    std::cout << \"plz enter:\\n\";\n    while (std::cin >> i && i != 999) sptr_vi->push_back(i);\n}\n\nvoid dynamic_vector_printer_sptr(\n    const std::shared_ptr<std::vector<int>> sptr_vi)\n{\n    for (const auto& e : *sptr_vi) std::cout << e << \" \";\n    std::cout << \"\\n\";\n}\n","text":"ex12_07.cpp"}
{"code":"/***************************************************************************\n *  @file       The code is for the exercises in C++ Primmer 5th Edition\n *  @author     Alan.W\n *  @date       23  DEC 2013\n *  @remark\n ***************************************************************************/\n//!\n//! Exercise 12.10:\n//! Explain whether the following call to the process function defined on page\n//! 464 is correct. If not, how would you correct the call?\n//  correct.\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <memory>\n\nvoid process(std::shared_ptr<int> ptr)\n{\n    std::cout << \"inside the process function:\" << ptr.use_count() << \"\\n\";\n}\n\nint main()\n{\n    std::shared_ptr<int> p(new int(42));\n    process(std::shared_ptr<int>(p));\n\n    /**\n      * codes below shows how the reference count change.\n      */\n    std::cout << p.use_count() << \"\\n\";\n    auto q = p;\n    std::cout << p.use_count() << \"\\n\";\n    std::cout << \"the int p now points to is:\" << *p << \"\\n\";\n    return 0;\n}\n","text":"ex12_10.cpp"}
{"code":"/***************************************************************************\n *  @file       The code is for the exercises in C++ Primmer 5th Edition\n *  @author     Alan.W\n *  @date       23  DEC 2013\n *  @remark\n ***************************************************************************/\n//!\n//! Exercise 12.11:\n//! What would happen if we called process as follows?\n//  An error was generated at run time : double free or corruption.\n//  See the comments below.\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <memory>\n\nvoid process(std::shared_ptr<int> ptr)\n{\n    std::cout << \"inside the process function:\" << ptr.use_count() << \"\\n\";\n}\n\nint main()\n{\n    std::shared_ptr<int> p(new int(42));\n\n    /**\n     * @brief   std::shared_ptr<int>(p.get()) construct a temporary shared_ptr\n     * and copy it\n     *          to the parameter.However it is not a copy of p. As a result, at\n     * end of this\n     *          main function p will free the memory that has been freed inside\n     * process ().\n     *          That's why \"double freed or corruption\" was generated.\n     */\n    process(std::shared_ptr<int>(p.get()));\n\n    return 0;\n}\n","text":"ex12_11.cpp"}
{"code":"/***************************************************************************\n *  @file       The code is for the exercises in C++ Primmer 5th Edition\n *  @author     Alan.W\n *  @date       23  DEC 2013\n *  @remark\n ***************************************************************************/\n//!\n//! Exercise 12.12:\n//! Using the declarations of p and sp explain each of the following calls to\n//! process. If the call is legal, explain what it does. If the call is illegal,\n//! explain why:\n//  See comments below.\n//!\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <memory>\n\nvoid process(std::shared_ptr<int> ptr)\n{\n    std::cout << \"inside the process function:\" << ptr.use_count() << \"\\n\";\n}\n\nint main()\n{\n    auto p = new int();\n    auto sp = std::make_shared<int>();\n\n    /** @brief\n     *  legal. Just copy sp which is a shared_ptr to process().\n     */\n    // process(sp);\n\n    /** @brief\n     *  illegale.plain pointer can not convert to smart pointer implicitly.\n     */\n    // process(new int());\n\n    /** @brief\n     *  illegale.plain pointer can not convert to smart pointer implicitly.\n     */\n    // process(p);\n\n    /** @brief\n     *  Legal. But it's a bad practice to do so.\n     *  Because using smart pointer together with raw pointer could potentially\n     * cause problems.\n     *  For example double free as shown in #145.\n     *\n     *  Check issue #145 for detail, thx @endyul for reporting\n     */\n    // process(std::shared_ptr<int>(p));\n\n    return 0;\n}\n","text":"ex12_12.cpp"}
{"code":"//! @Yue Wang\n//!\n//! ex12.13 What happens if we excute the following code?\n//!\n//  generate a runtime error : double free\n//!\n\n#include <iostream>\n#include <memory>\n\nint main()\n{\n    {\n        auto sp = std::make_shared<int>();\n        auto p = sp.get();\n        delete p;\n    }\n\n    return 0;\n}\n","text":"ex12_13.cpp"}
{"code":"//\n//  ex12_14.cpp\n//  Exercise 12.14\n//\n//  Created by pezy on 12/22/14.\n//  Copyright (c) 2014 pezy. All rights reserved.\n//\n//  Write your own version of a function that uses a shared_ptr to manage a\n//  connection.\n\n#include <iostream>\n#include <string>\n#include <memory>\n\nstruct connection {\n    std::string ip;\n    int port;\n    connection(std::string ip_, int port_) : ip(ip_), port(port_) {}\n};\nstruct destination {\n    std::string ip;\n    int port;\n    destination(std::string ip_, int port_) : ip(ip_), port(port_) {}\n};\n\nconnection connect(destination* pDest)\n{\n    std::shared_ptr<connection> pConn(new connection(pDest->ip, pDest->port));\n    std::cout << \"creating connection(\" << pConn.use_count() << \")\"\n              << std::endl;\n    return *pConn;\n}\n\nvoid disconnect(connection pConn)\n{\n    std::cout << \"connection close(\" << pConn.ip << \":\" << pConn.port << \")\"\n              << std::endl;\n}\n\nvoid end_connection(connection* pConn)\n{\n    disconnect(*pConn);\n}\n\nvoid f(destination& d)\n{\n    connection conn = connect(&d);\n    std::shared_ptr<connection> p(&conn, end_connection);\n    std::cout << \"connecting now(\" << p.use_count() << \")\" << std::endl;\n}\n\nint main()\n{\n    destination dest(\"202.118.176.67\", 3316);\n    f(dest);\n}","text":"ex12_14.cpp"}
{"code":"//\n//  ex12_15.cpp\n//  Exercise 12.15\n//\n//  Created by pezy on 12/22/14.\n//  Copyright (c) 2014 pezy. All rights reserved.\n//\n//  Rewrite the first exercise to use a lambda (10.3.2, p.388) in place of the\n//  end_connection function.\n\n#include <iostream>\n#include <string>\n#include <memory>\n\nstruct connection {\n    std::string ip;\n    int port;\n    connection(std::string ip_, int port_) : ip(ip_), port(port_) {}\n};\nstruct destination {\n    std::string ip;\n    int port;\n    destination(std::string ip_, int port_) : ip(ip_), port(port_) {}\n};\n\nconnection connect(destination* pDest)\n{\n    std::shared_ptr<connection> pConn(new connection(pDest->ip, pDest->port));\n    std::cout << \"creating connection(\" << pConn.use_count() << \")\"\n              << std::endl;\n    return *pConn;\n}\n\nvoid disconnect(connection pConn)\n{\n    std::cout << \"connection close(\" << pConn.ip << \":\" << pConn.port << \")\"\n              << std::endl;\n}\n\nvoid f(destination& d)\n{\n    connection conn = connect(&d);\n    std::shared_ptr<connection> p(&conn, [](connection* p) { disconnect(*p); });\n    std::cout << \"connecting now(\" << p.use_count() << \")\" << std::endl;\n}\n\nint main()\n{\n    destination dest(\"202.118.176.67\", 3316);\n    f(dest);\n}","text":"ex12_15.cpp"}
{"code":"//\n//  ex12_15.cpp\n//  Exercise 12.15\n//\n//  Created by pezy on 12/22/14.\n//  Copyright (c) 2014 pezy. All rights reserved.\n//\n//  Compilers don’t always give easy-to-understand error messages if we attempt\n//  to\n//  copy or assign a unique_ptr. Write a program that contains these errors to\n//  see\n//  how your compiler diagnoses them.\n\n#include <iostream>\n#include <string>\n#include <memory>\n\nusing std::string;\nusing std::unique_ptr;\n\nint main()\n{\n    unique_ptr<string> p1(new string(\"pezy\"));\n    // unique_ptr<string> p2(p1); // copy\n    //                      ^\n    // Error: Call to implicitly-deleted copy constructor of\n    // 'unique_ptr<string>'\n    //\n    // unique_ptr<string> p3 = p1; // assign\n    //                      ^\n    // Error: Call to implicitly-deleted copy constructor of\n    // 'unique_ptr<string>'\n    std::cout << *p1 << std::endl;\n    p1.reset(nullptr);\n}","text":"ex12_16.cpp"}
{"code":"/***************************************************************************\n *  @file       The code is for the exercises in C++ Primmer 5th Edition\n *  @author     Alan.W\n *  @date       24  DEC 2013\n *  @remark\n ***************************************************************************/\n//!\n//! Exercise 12.17:\n//! Which of the following unique_ptr declarations are illegal or likely to\n//! result in subsequent program error? Explain what the problem is with each\n//! one.\n//!\n//! Exercise 12.18:\n//! Why doesn’t shared_ptr have a release member?\n//  Because other shared_ptr that points the same object can still delete this\n//  object.Thus, it's meaningless to provide this member\n//  more detail can be found a thread on Stack Overflow:\n//  http://stackoverflow.com/questions/1525764/how-to-release-pointer-from-boostshared-ptr\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <memory>\n\nint main()\n{\n    int ix = 1024, *pi = &ix, *pi2 = new int(2048);\n    typedef std::unique_ptr<int> IntP;\n\n    /**\n     * @brief  error: invalid conversion from 'int' to\n     * 'std::unique_ptr<int>::pointer {aka int*}' [-fpermissive]\n     */\n    // IntP p0(ix);\n\n    /**\n     * @brief The code below can compile, but will cause error at run time.\n     *        The reason is that when the unique_ptr p1 is out of scope, delete\n     * will be called\n     *        to free th object. But the object is not allocate using new.Thus,\n     * an error\n     *        would be thrown by operating system.\n     *  @badcode\n     */\n    // IntP p1(pi);\n\n    /**\n     * @brief This code can compile, but cause a dangling pointer at run time.\n     *        The reason is that the unique_ptr will free the object the raw\n     * pointer\n     *        is pointing to.\n     * @badcode\n     */\n    //{IntP p2(pi2);}\n\n    /**\n     * @brief   When the unique_ptr goes out of scope, it will call delete to\n     * free an\n     *          obeject not allocated using new.\n     * @badcode\n     */\n    // IntP p3(&ix);\n\n    /**\n     * @brief   Recommended.\n     */\n    // IntP p4(new int(2048));\n\n    /**\n     * @brief   error:   double free or corruption at run time\n     *          two unique_ptr are pointing to the same object. Thus, when both\n     * are out of\n     *          scope, Operating system will throw double free or corruption.\n     * @badcode\n     */\n    // IntP p2(new int(555));\n    // IntP p5(p2.get());\n\n    return 0;\n}\n","text":"ex12_17_18.cpp"}
{"code":"//\n//  ex12_19.cpp\n//  Exercise 12.19\n//\n//  Created by pezy on 12/26/14.\n//  Copyright (c) 2014 pezy. All rights reserved.\n//\n//  Define your own version of StrBlobPtr and\n//  update your StrBlob class with the appropriate friend declaration and begin\n//  and end members.\n//\n//  @See    ex12_19.h\n\n#include \"ex12_19.h\"\n\nStrBlobPtr StrBlob::begin()\n{\n    return StrBlobPtr(*this);\n}\nStrBlobPtr StrBlob::end()\n{\n    return StrBlobPtr(*this, data->size());\n}\n","text":"ex12_19.cpp"}
{"code":"//\n//  ex12_20.cpp\n//  Exercise 12.20\n//\n//  Created by pezy on 12/26/14.\n//  Copyright (c) 2014 pezy. All rights reserved.\n//\n//  Write a program that reads an input file a line at a time into\n//  a StrBlob and uses a StrBlobPtr to print each element in that StrBlob.\n\n#include \"ex12_19.h\"\n#include <fstream>\n#include <iostream>\n\nint main()\n{\n    std::ifstream ifs(\"../data/book.txt\");\n    StrBlob blob;\n    for (std::string str; std::getline(ifs, str);) blob.push_back(str);\n    for (StrBlobPtr pbeg(blob.begin()), pend(blob.end()); pbeg != pend;\n         pbeg.incr())\n        std::cout << pbeg.deref() << std::endl;\n}","text":"ex12_20.cpp"}
{"code":"//\n//  ex12_22.cpp\n//  CP5\n//\n//  Created by pezy on 1/2/15.\n//  Copyright (c) 2015 pezy. All rights reserved.\n//\n\n#include \"ex12_22.h\"\n\nConstStrBlobPtr StrBlob::begin() const // should add const\n{\n    return ConstStrBlobPtr(*this);\n}\nConstStrBlobPtr StrBlob::end() const // should add const\n{\n    return ConstStrBlobPtr(*this, data->size());\n}","text":"ex12_22.cpp"}
{"code":"//\n//  ex12_23.cpp\n//  Exercise 12.23\n//\n//  Created by pezy on 12/30/14.\n//  Updated by sanerror on 11/9/16.\n//  Copyright (c) 2014 pezy. All rights reserved.\n//\n//  Write a program to concatenate two string literals, putting the result in a\n//  dynamically allocated array of char.\n//  Write a program to concatenate two library strings that have the same value\n//  as the literals used in the first program.\n\n#include <iostream>\n#include <string>\n#include <cstring>\n\nint main() {\n\tconst char *c1 = \"Hello \";\n\tconst char *c2 = \"World\";\n\tunsigned len = strlen(c1) + strlen(c2) + 1;\n\tchar *r = new char[len]();\n\tstrcat_s(r, len, c1);\n\tstrcat_s(r, len, c2);\n\tstd::cout << r << std::endl;\n\n\tstd::string s1 = \"Hello \";\n\tstd::string s2 = \"World\";\n\tstrcpy_s(r, len, (s1 + s2).c_str());\n\tstd::cout << r << std::endl;\n\n\tdelete[] r;\n\n\treturn 0;\n}\n","text":"ex12_23.cpp"}
{"code":"//\n//  ex12_24.cpp\n//  Exercise 12.24\n//\n//  Created by pezy on 12/30/14.\n//  Copyright (c) 2014 pezy. All rights reserved.\n//\n//  Write a program that reads a string from the standard input into a\n//  dynamically allocated character array.\n//  Describe how your program handles varying size inputs.\n//  Test your program by giving it a string of data that is longer than the\n//  array size you've allocated.\n\n#include <iostream>\n\nint main()\n{\n    // need to tell the size.\n    std::cout << \"How long do you want the string? \";\n    int size{0};\n    std::cin >> size;\n    char* input = new char[size + 1]();\n    std::cin.ignore();\n    std::cout << \"input the string: \";\n    std::cin.get(input, size + 1);\n    std::cout << input;\n    delete[] input;\n    // Test: if longer than the array size, we will lost the characters which\n    // are out of range.\n}\n","text":"ex12_24.cpp"}
{"code":"//\n//  ex12_26.cpp\n//  Exercise 12.26\n//\n//  Created by pezy on 12/30/14.\n//  Copyright (c) 2014 pezy. All rights reserved.\n//\n//  Rewrite the program on page 481 using an allocator.\n\n#include <iostream>\n#include <string>\n#include <memory>\n\nvoid input_reverse_output_string(int n)\n{\n    std::allocator<std::string> alloc;\n    auto const p = alloc.allocate(n);\n    std::string s;\n    auto q = p;\n    while (std::cin >> s && q != p + n) alloc.construct(q++, s);\n\n    while (q != p) {\n        std::cout << *--q << \" \";\n        alloc.destroy(q);\n    }\n    alloc.deallocate(p, n);\n}\n\nint main()\n{\n    input_reverse_output_string(5);\n}\n","text":"ex12_26.cpp"}
{"code":"//\n//  ex12_27.cpp\n//  Exercise 12.27\n//\n//  Created by pezy on 12/31/14.\n//  Copyright (c) 2014 pezy. All rights reserved.\n//\n//  The TextQuery and QueryResult classes use only capabilities that we have\n//  already covered.\n//  Without looking ahead, write your own versions of these classes.\n\n#include \"ex12_27_30.h\"\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n\nTextQuery::TextQuery(std::ifstream& ifs) : input(new vector<string>)\n{\n    LineNo lineNo{0};\n    for (string line; std::getline(ifs, line); ++lineNo) {\n        input->push_back(line);\n        std::istringstream line_stream(line);\n        for (string text, word; line_stream >> text; word.clear()) {\n            // avoid read a word followed by punctuation(such as: word, )\n            std::remove_copy_if(text.begin(), text.end(),\n                                std::back_inserter(word), ispunct);\n            // use reference avoid count of shared_ptr add.\n            auto& nos = result[word];\n            if (!nos) nos.reset(new std::set<LineNo>);\n            nos->insert(lineNo);\n        }\n    }\n}\n\nQueryResult TextQuery::query(const string& str) const\n{\n    // use static just allocate once.\n    static shared_ptr<std::set<LineNo>> nodate(new std::set<LineNo>);\n    auto found = result.find(str);\n    if (found == result.end())\n        return QueryResult(str, nodate, input);\n    else\n        return QueryResult(str, found->second, input);\n}\n\nstd::ostream& print(std::ostream& out, const QueryResult& qr)\n{\n    out << qr.word << \" occurs \" << qr.nos->size()\n        << (qr.nos->size() > 1 ? \" times\" : \" time\") << std::endl;\n    for (auto i : *qr.nos)\n        out << \"\\t(line \" << i + 1 << \") \" << qr.input->at(i) << std::endl;\n    return out;\n}\n","text":"ex12_27_30.cpp"}
{"code":"//\n//  ex12_27_TEST.cpp\n//  Exercise 12.27\n//\n//  Created by pezy on 12/31/14.\n//  Copyright (c) 2014 pezy. All rights reserved.\n//\n//  The TextQuery and QueryResult classes use only capabilities that we have\n//  already covered.\n//  Without looking ahead, write your own versions of these classes.\n\n#include \"ex12_27_30.h\"\n#include <iostream>\n\nvoid runQueries(std::ifstream& infile)\n{\n    TextQuery tq(infile);\n    while (true) {\n        std::cout << \"enter word to look for, or q to quit: \";\n        string s;\n        if (!(std::cin >> s) || s == \"q\") break;\n        print(std::cout, tq.query(s)) << std::endl;\n    }\n}\n\nint main()\n{\n    std::ifstream file(\"../data/storyDataFile.txt\");\n    runQueries(file);\n}\n","text":"ex12_27_30_TEST.cpp"}
{"code":"//\n//  ex12_28.cpp\n//  Exercise 12.28\n//\n//  Created by pezy on 1/1/15.\n//  Copyright (c) 2015 pezy. All rights reserved.\n//\n//  Write a program to implement text queries without defining classes to manage\n//  the data.\n//  Your program should take a file and interact with a user to query for words\n//  in that file.\n//  Use vector, map, and set containers to hold the data for the file and\n//  to generate the results for the queries.\n\n#include <string>\nusing std::string;\n\n#include <vector>\nusing std::vector;\n\n#include <memory>\nusing std::shared_ptr;\n\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <algorithm>\n\nint main()\n{\n    std::ifstream file(\"../data/letter.txt\");\n    vector<string> input;\n    std::map<string, std::set<decltype(input.size())>> dictionary;\n    decltype(input.size()) lineNo{0};\n\n    for (string line; std::getline(file, line); ++lineNo) {\n        input.push_back(line);\n        std::istringstream line_stream(line);\n        for (string text, word; line_stream >> text; word.clear()) {\n            std::remove_copy_if(text.begin(), text.end(),\n                                std::back_inserter(word), ispunct);\n            dictionary[word].insert(lineNo);\n        }\n    }\n\n    while (true) {\n        std::cout << \"enter word to look for, or q to quit: \";\n        string s;\n        if (!(std::cin >> s) || s == \"q\") break;\n        auto found = dictionary.find(s);\n        if (found != dictionary.end()) {\n            std::cout << s << \" occurs \" << found->second.size()\n                      << (found->second.size() > 1 ? \" times\" : \" time\")\n                      << std::endl;\n            for (auto i : found->second)\n                std::cout << \"\\t(line \" << i + 1 << \") \" << input.at(i)\n                          << std::endl;\n        }\n        else\n            std::cout << s << \" occurs 0 time\" << std::endl;\n    }\n}\n","text":"ex12_28.cpp"}
{"code":"//\n//  ex12_32.cpp\n//  Exercise 12.32\n//\n//  Created by pezy on 1/1/15.\n//  Copyright (c) 2015 pezy. All rights reserved.\n//\n//  Rewrite the TextQuery and QueryResult classes to use a StrBlob\n//  instead of a vector<string> to hold the input file.\n\n#include \"ex12_32.h\"\n#include <sstream>\n#include <algorithm>\n\nTextQuery::TextQuery(std::ifstream& ifs) : input(new StrBlob)\n{\n    StrBlob::size_type lineNo{0};\n    for (string line; std::getline(ifs, line); ++lineNo) {\n        input->push_back(line);\n        std::istringstream line_stream(line);\n        for (string text, word; line_stream >> text; word.clear()) {\n            // avoid read a word followed by punctuation(such as: word, )\n            std::remove_copy_if(text.begin(), text.end(),\n                                std::back_inserter(word), ispunct);\n            // use reference avoid count of shared_ptr add.\n            auto& nos = result[word];\n            if (!nos) nos.reset(new std::set<StrBlob::size_type>);\n            nos->insert(lineNo);\n        }\n    }\n}\n\nQueryResult TextQuery::query(const string& str) const\n{\n    // use static just allocate once.\n    static shared_ptr<std::set<StrBlob::size_type>> nodate(\n        new std::set<StrBlob::size_type>);\n    auto found = result.find(str);\n    if (found == result.end())\n        return QueryResult(str, nodate, input);\n    else\n        return QueryResult(str, found->second, input);\n}\n\nstd::ostream& print(std::ostream& out, const QueryResult& qr)\n{\n    out << qr.word << \" occurs \" << qr.nos->size()\n        << (qr.nos->size() > 1 ? \" times\" : \" time\") << std::endl;\n    for (auto i : *qr.nos) {\n        ConstStrBlobPtr p(*qr.input, i);\n        out << \"\\t(line \" << i + 1 << \") \" << p.deref() << std::endl;\n    }\n    return out;\n}\n","text":"ex12_32.cpp"}
{"code":"//\n//  ex12_33.cpp\n//  Exercise 12.33\n//\n//  Created by pezy on 1/1/15.\n//  Copyright (c) 2015 pezy. All rights reserved.\n//\n//  Rewrite the TextQuery and QueryResult classes to use a StrBlob\n//  instead of a vector<string> to hold the input file.\n\n#include \"ex12_33.h\"\n#include <sstream>\n#include <algorithm>\n\nTextQuery::TextQuery(std::ifstream& ifs) : input(new StrBlob)\n{\n    StrBlob::size_type lineNo{0};\n    for (string line; std::getline(ifs, line); ++lineNo) {\n        input->push_back(line);\n        std::istringstream line_stream(line);\n        for (string text, word; line_stream >> text; word.clear()) {\n            // avoid read a word followed by punctuation(such as: word, )\n            std::remove_copy_if(text.begin(), text.end(),\n                                std::back_inserter(word), ispunct);\n            // use reference avoid count of shared_ptr add.\n            auto& nos = result[word];\n            if (!nos) nos.reset(new std::set<StrBlob::size_type>);\n            nos->insert(lineNo);\n        }\n    }\n}\n\nQueryResult TextQuery::query(const string& str) const\n{\n    // use static just allocate once.\n    static shared_ptr<std::set<StrBlob::size_type>> nodate(\n        new std::set<StrBlob::size_type>);\n    auto found = result.find(str);\n    if (found == result.end())\n        return QueryResult(str, nodate, input);\n    else\n        return QueryResult(str, found->second, input);\n}\n\nstd::ostream& print(std::ostream& out, const QueryResult& qr)\n{\n    out << qr.word << \" occurs \" << qr.nos->size()\n        << (qr.nos->size() > 1 ? \" times\" : \" time\") << std::endl;\n    for (auto it = qr.begin(); it != qr.end(); ++it) {\n        ConstStrBlobPtr p(*qr.get_file(), *it);\n        out << \"\\t(line \" << *it + 1 << \") \" << p.deref() << std::endl;\n    }\n    return out;\n}\n","text":"ex12_33.cpp"}
